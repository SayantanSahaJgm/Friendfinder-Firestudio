/**
 * @file Firebase Security Rules for FriendFinder App
 *
 * @core_philosophy This ruleset employs a mixed security model. User data is strictly controlled
 *  by the owning user. Posts and Stories are publicly readable but writable only by the owner.
 *
 * @data_structure
 * - /users/{userId}: User profile data, accessible only by the owning user.
 * - /posts/{postId}: Publicly readable posts, writable only by the author.
 * - /posts/{postId}/likes/{likeId}: Likes for posts, writable only by the liker.
 * - /posts/{postId}/comments/{commentId}: Comments for posts, writable only by the commenter.
 * - /stories/{storyId}: Publicly readable stories, writable only by the author.
 * - /friendRequests/{requestId}: Friend requests between users, writable only by the involved users.
 *
 * @key_security_decisions
 * - Users cannot list all users. This is to prevent data scraping and enumeration.
 * - Posts and stories are publicly readable to enable an open discovery experience.
 * - Strict ownership is enforced for user profiles and the creation/modification of content.
 *
 * @denormalization_for_authorization
 * - Posts and stories denormalize user information (username, profilePictureUrl) to avoid costly `get()` calls for display purposes.
 *
 * @structural_segregation
 * - Stories are stored in a top-level collection, separate from user-private data, to allow for public listing.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profile data. Only the owning user can read or write their profile.
     * @path /users/{userId}
     * @allow (create) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can create their profile if request.auth.uid == userId
     * @allow (get, update, delete) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can access their profile if request.auth.uid == userId
     * @deny (create) - User "OtherUser" cannot create a profile for "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @deny (get, update, delete) - User "OtherUser" cannot access the profile of "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      // Users cannot list all users
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Defines access control for posts. Anyone can read a post, but only the author can create, update, or delete it.
     * @path /posts/{postId}
     * @allow (get, list) - Any user can read posts.
     * @allow (create) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can create a post if request.resource.data.userId == request.auth.uid.
     * @allow (update, delete) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can modify a post if they are the author.
     * @deny (create) - User "OtherUser" cannot create a post attributed to "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @deny (update, delete) - User "OtherUser" cannot modify a post created by "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @principle Public read, owner-only writes, and validates relational integrity on create.
     */
    match /posts/{postId} {
      function isPostOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingPostOwner(userId) {
        return isPostOwner(userId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingPostOwner(resource.data.userId);
      allow delete: if isExistingPostOwner(resource.data.userId);
    }

    /**
     * @description Controls access to likes for a specific post.  Only authenticated users can create a like.  Only the user who created the like can delete it.
     * @path /posts/{postId}/likes/{likeId}
     * @allow (create) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can create a like on a post if request.resource.data.userId == request.auth.uid.
     * @allow (get, list) - Any user can read the likes for a post.
     * @allow (delete) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can delete their like.
     * @deny (create) - User "OtherUser" cannot create a like attributed to "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @deny (delete) - User "OtherUser" cannot delete a like created by "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @principle Owner-only writes and validates relational integrity on create.
     */
    match /posts/{postId}/likes/{likeId} {
      function isLikeOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingLikeOwner(userId) {
        return isLikeOwner(userId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if isExistingLikeOwner(resource.data.userId);
    }

    /**
     * @description Controls access to comments for a specific post. Only authenticated users can create a comment. Only the user who created the comment can update/delete it.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (create) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can create a comment on a post if request.resource.data.userId == request.auth.uid.
     * @allow (get, list) - Any user can read the comments for a post.
     * @allow (update, delete) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can update or delete their comment.
     * @deny (create) - User "OtherUser" cannot create a comment attributed to "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @deny (update, delete) - User "OtherUser" cannot update or delete a comment created by "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @principle Owner-only writes and validates relational integrity on create.
     */
    match /posts/{postId}/comments/{commentId} {
      function isCommentOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingCommentOwner(userId) {
        return isCommentOwner(userId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingCommentOwner(resource.data.userId);
      allow delete: if isExistingCommentOwner(resource.data.userId);
    }

    /**
     * @description Defines access control for stories. Anyone can read a story, but only the author can create, update, or delete it.
     * @path /stories/{storyId}
     * @allow (get, list) - Any user can read stories.
     * @allow (create) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can create a story if request.resource.data.userId == request.auth.uid.
     * @allow (update, delete) - User "L5I3dJExTNYPAHtIckXQLltU2fn1" can modify a story if they are the author.
     * @deny (create) - User "OtherUser" cannot create a story attributed to "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @deny (update, delete) - User "OtherUser" cannot modify a story created by "L5I3dJExTNYPAHtIckXQLltU2fn1".
     * @principle Public read, owner-only writes, and validates relational integrity on create.
     */
    match /stories/{storyId} {
      function isStoryOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingStoryOwner(userId) {
        return isStoryOwner(userId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingStoryOwner(resource.data.userId);
      allow delete: if isExistingStoryOwner(resource.data.userId);
    }

       /**
        * @description Controls access to friend requests.  Only the involved users can read or modify the request.
        * @path /friendRequests/{requestId}
        * @allow (create) - User can create a friend request where they are either the sender or receiver.
        * @allow (get) - User can get a friend request where they are either the sender or receiver.
        * @allow (update) - User can update a friend request where they are either the sender or receiver.
        * @allow (delete) - User can delete a friend request where they are either the sender or receiver.
        * @deny (list) - Friend requests should not be listable.
        * @deny (create) - User cannot create a request for unrelated users.
        * @deny (get, update, delete) - User cannot access friend requests they are not involved in.
        * @principle Shared access between two users.
        */
    match /friendRequests/{requestId} {
        function isRequestParticipant(userId) {
            return isSignedIn() && (request.resource.data.from == userId || request.resource.data.to == userId || resource.data.from == userId || resource.data.to == userId);
        }

        function isExistingRequestParticipant(userId) {
            return isRequestParticipant(userId) && resource != null;
        }

        allow get: if isExistingRequestParticipant(request.auth.uid);
        allow list: if false;
        allow create: if isSignedIn() && (request.resource.data.from == request.auth.uid || request.resource.data.to == request.auth.uid) && request.resource.data.id == requestId;
        allow update: if isExistingRequestParticipant(request.auth.uid);
        allow delete: if isExistingRequestParticipant(request.auth.uid);
    }


    function isSignedIn() {
      return request.auth != null;
    }
  }
}