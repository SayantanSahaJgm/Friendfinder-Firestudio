/**
 * @fileoverview Firestore Security Rules for FriendFinder App
 *
 * Core Philosophy:
 * This ruleset prioritizes security and data ownership. Users can only read and
 * modify their own data in their designated user subcollections. Top-level
 * collections are generally publicly readable but writable only by authenticated users
 * with appropriate authorization.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles. Only the authenticated user
 *   can access their own profile data.
 * - /posts/{postId}: Stores posts made by users. Publicly readable, but only the
 *   creator can modify or delete.
 * - /posts/{postId}/likes/{likeId}: Stores likes for each post. Only authenticated users can create likes. Deletion is restricted to the like owner.
 * - /posts/{postId}/comments/{commentId}: Stores comments for each post. Only authenticated users can create comments. Deletion is restricted to the comment owner.
 * - /stories/{storyId}: Stores user stories. Publicly readable, but only the
 *   creator can modify or delete.
 * - /friendRequests/{requestId}: Stores friend requests. Only involved users can manage requests.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied.
 * - Data validation is minimized for rapid prototyping, focusing on relational
 *   integrity and authorization.
 * - Public read access is granted to the `/posts` and `/stories` collections to enable feed functionality, with owner-only write access.
 *
 * Denormalization for Authorization:
 * - The `Post` and `Story` entities include a `userId` field.  Rules check this field against `request.auth.uid` to enforce ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile data, allowing only the owner to read and write.
     * @path /users/{userId}
     * @allow (get, create, update, delete) if the request is made by the user with matching {userId}.
     *   Example: request.auth.uid == 'user123' and path == '/users/user123'
     * @deny (get, create, update, delete) if the request is made by a different user.
     *   Example: request.auth.uid == 'user456' and path == '/users/user123'
     * @principle Enforces strict user-ownership for private data.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures posts, allowing public read access but restricting writes to the owner.
     * @path /posts/{postId}
     * @allow (get, list) Public read access to enable feed functionality.
     * @allow (create) if the request is made by an authenticated user, and the userId matches request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user123'
     * @allow (update, delete) if the request is made by the owner of the post.
     *   Example: request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @deny (create) if the userId in the request data does not match the authenticated user's ID.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user456'
     * @deny (update, delete) if the request is not made by the owner of the post.
     *   Example: request.auth.uid == 'user456' and resource.data.userId == 'user123'
     * @principle Allows public reads with owner-only writes. Enforces document ownership for writes.
     */
    match /posts/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Secures likes for a specific post, restricting creation to authenticated users and deletion to the owner of the like.
     * @path /posts/{postId}/likes/{likeId}
     * @allow (create) if the request is made by an authenticated user and the userId matches request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user123'
     * @allow (delete) if the request is made by the owner of the like (userId matches request.auth.uid).
     *   Example: request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @deny (create) if the request is not made by an authenticated user or the userId does not match request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user456'
     * @deny (get, list, update) These operations are not permitted.
     * @deny (delete) if the request is not made by the owner of the like.
     *   Example: request.auth.uid == 'user456' and resource.data.userId == 'user123'
     * @principle Enforces ownership for like creation and deletion.
     */
    match /posts/{postId}/likes/{likeId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Secures comments for a specific post, restricting creation to authenticated users and deletion to the owner of the comment.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (create) if the request is made by an authenticated user and the userId matches request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user123'
     * @allow (delete) if the request is made by the owner of the comment (userId matches request.auth.uid).
     *   Example: request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @deny (create) if the request is not made by an authenticated user or the userId does not match request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user456'
     * @deny (get, list, update) These operations are not permitted.
     * @deny (delete) if the request is not made by the owner of the comment.
     *   Example: request.auth.uid == 'user456' and resource.data.userId == 'user123'
     * @principle Enforces ownership for comment creation and deletion.
     */
    match /posts/{postId}/comments/{commentId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Secures stories, allowing public read access but restricting writes to the owner.
     * @path /stories/{storyId}
     * @allow (get, list) Public read access to enable feed functionality.
     * @allow (create) if the request is made by an authenticated user, and the userId matches request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user123'
     * @allow (update, delete) if the request is made by the owner of the story.
     *   Example: request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @deny (create) if the userId in the request data does not match the authenticated user's ID.
     *   Example: request.auth.uid == 'user123' and request.resource.data.userId == 'user456'
     * @deny (update, delete) if the request is not made by the owner of the story.
     *   Example: request.auth.uid == 'user456' and resource.data.userId == 'user123'
     * @principle Allows public reads with owner-only writes. Enforces document ownership for writes.
     */
    match /stories/{storyId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Secures friend requests, allowing read/write access to involved users only.
     * @path /friendRequests/{requestId}
     * @allow (get) if the request is made by either the sender or receiver of the friend request.
     *   Example: request.auth.uid == 'user123' and (resource.data.from == 'user123' or resource.data.to == 'user123')
     * @allow (create) if the request is made by an authenticated user, and the 'from' field matches request.auth.uid.
     *   Example: request.auth.uid == 'user123' and request.resource.data.from == 'user123'
     * @allow (update, delete) if the request is made by either the sender or receiver of the friend request, and the request exists.
     *   Example: request.auth.uid == 'user123' and (resource.data.from == 'user123' or resource.data.to == 'user123')
     * @deny (get) if the request is not made by either the sender or receiver of the friend request.
     *   Example: request.auth.uid == 'user456' and resource.data.from == 'user123' and resource.data.to == 'user789'
     * @deny (create) if the 'from' field in the request data does not match the authenticated user's ID.
     *   Example: request.auth.uid == 'user123' and request.resource.data.from == 'user456'
     * @deny (update, delete) if the request is not made by either the sender or receiver of the friend request.
     *   Example: request.auth.uid == 'user456' and resource.data.from == 'user123' and resource.data.to == 'user789'
     * @principle Restricts access to friend requests to the users involved.
     */
    match /friendRequests/{requestId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isParticipant(from, to) {
            return isSignedIn() && (request.auth.uid == from || request.auth.uid == to);
        }

        function isExistingParticipant(from, to) {
            return isParticipant(from, to) && resource != null;
        }

        allow get: if isParticipant(resource.data.from, resource.data.to);
        allow list: if false;
        allow create: if isSignedIn() && request.resource.data.from == request.auth.uid;
        allow update: if isExistingParticipant(resource.data.from, resource.data.to);
        allow delete: if isExistingParticipant(resource.data.from, resource.data.to);
    }
  }
}