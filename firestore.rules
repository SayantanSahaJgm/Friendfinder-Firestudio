rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (get, update, delete) Authenticated user with matching userId.
     * @allow (create) Authenticated user creating their own profile.
     * @deny (get, list) Any user attempting to list all users.
     * @deny (get, update, delete) Any user attempting to access another user's profile.
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted

      // Allow the user to create their own profile, enforcing that the userId in the path matches their auth.uid
      allow create: if isSignedIn() && isOwner(userId);

      //On Update: You SHOULD enforce that the ownership field is immutable (e.g., request.resource.data.id == resource.data.id). This check is superior because it allows for partial updates (the client doesn't have to re-send the id field) while securely preventing the ownership link from ever being changed.
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure posts. Publicly readable, but only the owner can create/update/delete.
     * @path /posts/{postId}
     * @allow (get, list) Any user can read posts.
     * @allow (create) Authenticated user creating a post with their userId.
     * @allow (update, delete) Only the owner of the post can update/delete it.
     * @deny (create, update, delete) Unauthenticated users cannot create/update/delete posts.
     * @principle Public read access with owner-only writes for posts.
     */
    match /posts/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return resource.data.userId == request.auth.uid;
      }

      function isExistingOwner() {
        return isSignedIn() && isOwner() && resource != null;
      }

      allow get, list: if true; // Public read access

      // Validate that the incoming userId matches the user's auth UID on create
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secure likes. Only the user who created the like can read/write it.
     * @path /posts/{postId}/likes/{likeId}
     * @allow (get) Authenticated user accessing their own like.
     * @allow (create) Authenticated user creating their own like.
     * @allow (update, delete) Only the owner can update/delete the like.
     * @deny (list) Listing likes is not permitted.
     * @principle Enforces document ownership for likes.
     */
    match /posts/{postId}/likes/{likeId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.userId;
      }

     function isExistingOwner() {
        return isSignedIn() && isOwner() && resource != null;
      }

      allow get: if isOwner();
      allow list: if false; // Listing likes is not permitted
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secure comments. Only the user who created the comment can read/write it.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get) Authenticated user accessing their own comment.
     * @allow (create) Authenticated user creating their own comment.
     * @allow (update, delete) Only the owner can update/delete the comment.
     * @deny (list) Listing comments is not permitted.
     * @principle Enforces document ownership for comments.
     */
    match /posts/{postId}/comments/{commentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.userId;
      }
     function isExistingOwner() {
        return isSignedIn() && isOwner() && resource != null;
      }
      allow get: if isOwner();
      allow list: if false; // Listing comments is not permitted
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secure stories. Publicly readable, but only the owner can create/update/delete.
     * @path /stories/{storyId}
     * @allow (get, list) Any user can read stories.
     * @allow (create) Authenticated user creating a story with their userId.
     * @allow (update, delete) Only the owner of the story can update/delete it.
     * @deny (create, update, delete) Unauthenticated users cannot create/update/delete stories.
     * @principle Public read access with owner-only writes for stories.
     */
    match /stories/{storyId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return resource.data.userId == request.auth.uid;
      }

      function isExistingOwner() {
        return isSignedIn() && isOwner() && resource != null;
      }

      allow get, list: if true; // Public read access

      // Validate that the incoming userId matches the user's auth UID on create
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secure friend requests. Only the involved users can create/update/delete friend requests.
     * @path /friendRequests/{requestId}
     *  @allow (get) Only the involved users can get the friend request.
     * @allow (create) Only the involved users can create friend requests.
     * @allow (update, delete) Only the involved users can update/delete the friend request.
     * @deny (list) Listing friend requests is not permitted.
     * @principle Only the involved users can manage friend requests.
     */
    match /friendRequests/{requestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return isSignedIn() && (request.auth.uid == request.resource.data.from || request.auth.uid == request.resource.data.to);
      }

      function isExistingParticipant() {
        return isSignedIn() && (request.auth.uid == resource.data.from || request.auth.uid == resource.data.to) && resource != null;
      }

      allow get: if isExistingParticipant();
      allow list: if false; // Listing is not permitted
      allow create: if isParticipant();
      allow update: if isExistingParticipant();
      allow delete: if isExistingParticipant();
    }
  }
}